#include <iostream>
#include <fstream>
#include <sstream>
#include "autogenerated.gproto-classes/FullName.pb.h"
#include "autogenerated.gproto-classes/Student.pb.h"
#include "autogenerated.gproto-classes/StudentsGroup.pb.h"


/*
 * Установить библиотеку protobuf.
 * С помощью компилятора protobuf в отдельном пространстве имен сгенерировать классы
 *
 * FullName с полями имя, фамилия, отчество (отчество опционально).
 * Student с полями полное имя, массив оценок, средний балл.
 * StudentsGroup с полем массив студентов.
 */

/*
 *  Этот кусок дз я к сроку не успел, но обязательно сделаю.
 *
 * Создать класс StudentsGroup, который реализует интерфейсы:
class IRepository {
    virtual void Open() = 0; // бинарная десериализация в файл
    virtual void Save() = 0; // бинарная сериализация в файл
};


class IMethods {
    virtual double GetAverageScore(const FullName& name) = 0;
    virtual string GetAllInfo(const FullName& name) = 0;
    virtual string GetAllInfo() = 0;
};
 * */

class IRepository {
    virtual void Open() = 0; // бинарная десериализация в файл
    virtual void Save() = 0; // бинарная сериализация в файл
};

class IMethods {
    virtual double GetAverageScore(const sample::ns::FullName& name) = 0;
    virtual std::string GetAllInfo(const sample::ns::FullName& name) = 0;
    virtual std::string GetAllInfo() = 0;
};


class StudentsGroupSerializer : public IRepository, public IMethods {
    sample::ns::StudentsGroup  group;
    std::string fileName="./fileForSerialization.binary";

public:

    std::string GetAllInfo(const sample::ns::FullName& nameParam) override {
        for (auto i = group.students().begin(); i < group.students().end() ; ++i) {
            if (i->name().name() == nameParam.name() && i->name().family() == nameParam.family()
                && i->name().patronymic() == nameParam.patronymic() ) {
                    std::stringstream strstream;
                    strstream << i->name().name() << " " << i->name().patronymic() << " " << i->name().family() <<
                    ": " << i->average_mark() << std::endl;
                    return strstream.str();
            }
        }
        return "";
    }
    std::string GetAllInfo() override {
        std::stringstream strstream;
        for (auto i = group.students().begin(); i < group.students().end() ; ++i) {
            strstream << std::endl << i->name().name() << " " << i->name().patronymic() << " " << i->name().family() <<
                      ": " << i->average_mark() << std::endl;
        }
        return strstream.str();
    }

    double GetAverageScore(const sample::ns::FullName& nameParam) override {
        for (auto i = group.students().begin(); i < group.students().end() ; ++i) {
            if (i->name().name() == nameParam.name() && i->name().family() == nameParam.family()
                && i->name().patronymic() == nameParam.patronymic() )
                return (double ) i->average_mark();
        }

        return 0.0;
    }

    void initWithSampleData() {
        sample::ns::FullName fio;
        sample::ns::Student s;
        fio.set_name("Name1");
        fio.set_family("Family1");
        fio.set_patronymic("Patronymic1");
        *s.mutable_name() = fio;
        s.add_marks(3);
        s.add_marks(4);
        s.add_marks(5);
        s.set_average_mark((float )(3+4+5)/3.0);


        sample::ns::FullName Me;
        Me.set_family("Artemev");
        Me.set_name("Oleg");
        Me.set_patronymic("Konstantinovich");
        sample::ns::Student  geekbrainsStudent;
        //geekbrainsStudent.set_allocated_name(&Me); // this gives memory errors on free().
        *geekbrainsStudent.mutable_name() = Me;
        geekbrainsStudent.add_marks(4);
        geekbrainsStudent.add_marks(4);
        geekbrainsStudent.add_marks(5);
        int counter{0};int summ=0;
        for(auto mark=geekbrainsStudent.marks().begin();mark<geekbrainsStudent.marks().end();++mark) {
            std::cout << *mark << std::endl;
            summ+=*mark;
            ++counter;
        }
        geekbrainsStudent.set_average_mark((float )summ/counter);

        *group.add_students() = s;
        *group.add_students() = geekbrainsStudent;

        Save();
    }

    void print() {

        if(!group.IsInitialized()) {
            std::cout << "group is empty" << std::endl;
            return;
        }

        for (auto i = group.students().begin(); i < group.students().end() ; ++i) {
            std::cout << i->name().name() << i->name().family() << std::endl;
        }
    }

    StudentsGroupSerializer(const std::string file) : fileName{file}  {}


    void Open() {
        std::ifstream infs(fileName,std::ios_base::binary);
        if(!infs.is_open()) throw "Can't open ifstream for file (default: ./fileForSerialization.binary)";
        group.Clear();
        bool result = group.ParseFromIstream(&infs);
        if(!result) std::cout << "Cannot init StudentGroup from file!" << std::endl;
        else std::cout << "group.ParseFromFileDescriptor() has returned true." << std::endl;
        infs.close();
    }

    void Save() {
        std::ofstream outfs(fileName,std::ios_base::binary);
        if(!outfs.is_open()) throw "Can't get ofstream for file (default: ./fileForSerialization.binary)";

        bool result = group.SerializeToOstream(&outfs);
        if(!result) std::cout << "Cannot serialize to ostream." << std::endl;
        else std::cout << "group.SerializeToOstream() has returned true." << std::endl;
        outfs.close();
    }

};


int main() {

    StudentsGroupSerializer groupSerializer("/tmp/serialized.binary");

    groupSerializer.initWithSampleData();

    groupSerializer.print();

    std::cout << "==================" << std::endl;
    groupSerializer.Open();

    groupSerializer.print();
    std::cout << "==================" << std::endl;


    sample::ns::FullName Me;
    Me.set_family("Artemev");
    Me.set_name("Oleg");
    Me.set_patronymic("Konstantinovich");

    std::cout << "Average Score: " << groupSerializer.GetAverageScore(Me) << std::endl;

    std::cout << "==================" << std::endl;
    std::cout << groupSerializer.GetAllInfo(Me);

    std::cout << "==================" << std::endl;
    std::cout << groupSerializer.GetAllInfo();

    return 0;
}
